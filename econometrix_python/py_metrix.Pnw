\documentclass[pdftex,12pt,a4paper]{article}

\input{/home/boris/science/tex_general/title_bor_utf8}

\title{Эконометрика на Python'е}
\author{Борис Демешев\footnote{\href{mailto:boris.demeshev@gmail.com}{boris.demeshev@gmail.com}}}
\date{\today}



\begin{document}
\maketitle
\parindent=0 pt % отступ равен 0

\todolist

\section{О python'е}

Голый Питон не пригоден для анализа данных. 
Работать с данными позволяют множество библиотек.
Любая наша программа будет начинаться с комманд
<<term = True>>=
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
@



Вопросы по статистическим методам лучше задавать на \url{http://stats.stackexchange.com/}


Вопросы по Питону --- на \url{http://stackoverflow.com/}


Вопросы по \LaTeX'у --- на \url{http://tex.stackexchange.com/}

\section{Три стиля работы и графики}

На практике используются три стиля работы

\begin{enumerate}
\item Интерактивная работа. Вы вводите одну команду~--- она немедленно исполняется. 
Результаты вычислений и построенные графики видны сразу.
Для интерактивной работы существует специальная надстройка над питоном --- ipython.
Его мы и будем использовать.

\item Написание программы. 
Вы пишите длинную программу, запускаете её. 
Она думает несколько миллионов лет и выводит ответ на главный вопрос жизни, Вселенной и всего такого.

\item Создание \LaTeX документа с кодом на python'е с помощью Pweave.
Вы пишете статью, которая связана с анализом данных. 
Вы не хотите тратить время, сначала на вычисление среднего, а потом на вставку получившегося результата в итоговый отчет. 
Поэтому Вы сразу комбинируете \Latex'овский и питоновский код в одном файле.

\end{enumerate}

В интерактивном режиме имеет смысл попросить python выводить графики сразу. Делается это командой
<<term=True>>=
plt.ion()
@

При создании \LaTeX документов с помощью Pweave интерактивный режим включать не имеет смысла. Обычно вставка картинки выглядит так

\todo[inline]{Как сказать Pweave'у, что код исполнять не надо?}



\section{Генерация случайных чисел, базовые операции}


Питон можно использовать как калькулятор:
<<term = True>>=
print(2*(5+17))
@

Есть несколько особенностей.
\begin{enumerate}
\item Возведение в степень обозначается **
<<term = True>>=
print(2**10)
@
\item По умолчанию результат деления целого числа на целое считается целым, например
<<term = True>>=
print(90/8)
@

\end{enumerate}


\section{Функции, циклы и условия}

Простой пример функции
<<term = True>>=
def sq(x):
    """
    Given x this function return x*x
    """
    return(x*x)
@

Теперь воспользуемся нашей функцией
<<term = True>>=
print sq(4)
@

Обязательно пишите описание всех функций, которые Вы сочиняете! Описание расположено в начале функции и может занимать несколько строк, пишется между парой тройных кавычек.

Прочитать описание уже существующей функции можно так
<<term = True>>=
sq?
@

Более подробное описание
<<term = True>>=
sq??
@

Еще подойдет help(sq)



\section{Простая библиотека, организация работы (?)}

\url{http://archive.org/details/Perez_Python_Workshop_2008_10_09c}








\section{Загрузка данных}

Исходные данные нужно хранить в самом простом формате: в текстовом. О другом формате можно задуматься, только  если загрузка данных занимает слишком много времени. Преимущества текстового формата: читается всеми программами, читается человеком.

Например, проанализируем данные об извержениях гейзера OldFaithful за 2011 год. Сначала скачаем с сайта \url{http://www.geyserstudy.org/geyser.aspx?pGeyserNo=OLDFAITHFUL} эти данные и сохраним с именем \texttt{faithful_2011.txt}. Прямая ссылка на скачивание, \url{http://www.geyserstudy.org/geysers/OLDFAITHFUL/eruptions/Old%20Faithful%20eruptions%20for%202011.TXT}.

Смотрим этот файл в любом текстовом редакторе и видим такое начало:
\todo[inline]{Здесь надо добавить номера строк!}
\begin{verbatim}
2011 Old Faithful Geyser Eruptions

All times are local time (MST or MDT)

  Time and Date     Interval
  
12/31/10 23:26:21,  0:00:00
01/01/11 00:56:33,  1:30:12
01/01/11 02:22:21,  1:25:48
01/01/11 03:53:39,  1:31:18
...
\end{verbatim}

Первые 6 строчек не содержат данных, поэтому мы просим Панду их пропустить, skiprows=6. Придумываем имена двум имеющимся столбцам, скажем date_time и interval.
<<term=True>>=
faith=pd.read_csv('faithful_2011.txt',skiprows=6,names=['date_time','interval'])
@


Выводим информацию о наборе данных. Если наблюдений много --- будут напечатаны только названия переменных (столбцов DataFrame), если наблюдений мало --- то будут напечатаны сами наблюдения. 
<<term=True>>=
print faith
@

Узнаем тип каждой переменной:
<<term=True>>=
print faith.dtypes
@

Проверяем, не потеряли ли мы наблюдения в конце массива при загрузке
<<term=True>>=
print faith.tail()
@

Замечаем, что последнее <<наблюдение>> нужно удалить.
<<term=True>>=
faith=faith[0:-1]
@

Снова проверяем хвост нашего массива, чтобы убедиться, что всё в порядке.
<<term=True>>=
print faith.tail()
@







\section{Простые графики и описательные статистики}



\section{Классическая регрессионная модель}



\section{Логит, пробит}


\section{Временные ряды}


\section{Панельные данные}


\section{Монте-Карло на Марковских цепях}

\todo[inline]{И вручную и с помощью pymc}

\section{Парсинг Интернет-данных}




\section{Где карта, Билли?}


\section{Большие данные}











\end{document}